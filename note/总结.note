1,关于Update函数优化
	1)每帧检测时间的，可以放入TimedEvent处理
        2)需要间隔帧来触发的，可以放入FrameEvent处理
        3)需要检测某个状态的，可以放入事件系统来触发
        4)必须每帧来检测的，如检测两个玩家距离，
          如果这种需求较少，由可以使用注册函数的方式，避免不必要的空检测

2,尽量使用状态机描述对象状态。
  而不使用状态变量，需要的时候测试变量的状态。

3,使用对象池解决内存分配慢的问题，单线程无锁ObjectPool效率会比较高。
  特别像高频率分配的对象，或者内含其它需要New的对象的对象。
        1)相对于内存池，对象池可以保留对象本身的特点，
          比如虚函数表等，还有就是内部需要new的对象，不用重新创建或分配。

4,服务器使用限制帧技术
        1)可以在空转时降低资源消耗
        2)可以以帧为单位做一些逻辑或者优化，如消息帧打包。
        3)可以更好的实现服务器与客户端同步，帧同步或者其它。

5,使用单线程来实现逻辑块内部消息处理有序，
  如果一根线程抗不住，就将某一逻辑块整个移到另一根线程。

6,减少不必要的操作，如重复memcpy或者memset之类的。

7,不要过于纠结细小的性能优化，算法和编程水平带来的效果更加明显

8,尽量不使用默认参数，代码是优雅了，但大大增加了出错的概率，尤其是团队合作的时候。
  函数参数是有多个相同类型参数时，建议使用结构体传递，相当于具名参数，减少出错概率。
  
9,尽量不要在Mysql中存二进制或字符串
	1)分成每个字段，可以很方便的使用数据库的一些特性。
	  不然先得全部取出来，解析，再进行判断。
	2)游戏上线后，可能会出现数据出错，但一时又找不到原因。
	  而玩家是不会等的，此时运营就要手动改数据库了。
	  二进制根本没办法这类操作。
	3)字符串的解析本来就很耗性能，不可取。
	4)虽然开发的时候会省很多事，但出问题真心不好弄。

工具：
        https://github.com/davyxu/tabtoy

2017年3月6日 ===========================================================================
MySql表如果不设置主键，那么replace将当成insert使用，每次插入新的。
一个BUG，之前认为是程序逻辑错误，每次存取的数据不一样。
结果是本来应该replace的，默认成了insert，这样一个ID就有多条记录，而取的是第一条，肯定不对啊。

2017年3月13日 ===========================================================================
就一个公会战力排名，被策划弄得很烦，非得相同战力时，按创建时间排序。不过因祸得福：
1，发现了boost::multi_index_container设计的秘密。
   当std::map使用std::pair或std::tuple作为key时，如果第一个元素相同，则以第二个元素排序，以此类推。
   
2，std::multimap，当key值相同时，以插入顺序排列。
